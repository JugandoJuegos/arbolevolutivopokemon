<!doctype html>
<html lang="es">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Árbol Evolutivo Pokémon</title>
 <link rel="icon" href="favicon.png" type="image/png">
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<script src="https://d3js.org/d3.v7.min.js"></script>

<style>
  :root{
    --blue1:#c92b2b;
    --blue2:#8f1b1b;
    --red:#c92b2b;
    --red-dark:#8f1b1b;
  }


  html,body{height:100%;margin:0;background:#050615;color:#fff;font-family:Arial, sans-serif;overflow:hidden;} /* ocultamos scrollbar global para que la página no muestre barras */
  .wrap{display:flex;flex-direction:column;min-height:100vh}
  .main{display:flex;flex:1;overflow:hidden;position:relative}
  #tree{flex:3;min-width:320px;position:relative;overflow:hidden}
  #tree>svg{position:relative;z-index:2;background:transparent}
  #starfield{position:absolute;inset:0;z-index:0}


  .link {
    fill: none;
    filter: none !important;
    mix-blend-mode: normal !important;
    stroke-linecap: butt;
    stroke-linejoin: round;
    shape-rendering: geometricPrecision;
    pointer-events: none;
  }

#list{
  position: absolute;
  right: 12px;
  top: 12px;
  max-height: calc(100vh - 24px);
  height: auto;
  width: fit-content;
  max-width: calc(100% - 48px);
  min-width: 160px;
  padding: 18px;
  overflow-x: auto;
  overflow-y: auto;
  background: rgba(10, 10, 10, 0.75);
  box-sizing:border-box;
  z-index:380;
  transition: opacity .18s ease, transform .18s ease, visibility .18s ease;
  opacity: 1;
  transform: translateX(0);
  visibility: visible;
  pointer-events: auto;
  border-radius: 10px;
  backdrop-filter: blur(4px);
  -webkit-overflow-scrolling: touch;
  white-space: normal;
}

#nodeList li { cursor: pointer; }

#list.hidden{
  opacity: 0;
  transform: translateX(10px);
  visibility: hidden;
  pointer-events: none;
}

ul{display:block;padding-left:8px;margin:6px 0;color:#dfeeff}
li{display:block; margin:6px 0; white-space:normal; word-break:break-word;}
ul{display:block;padding-left:8px;margin:6px 0;color:#dfeeff}
li{display:block; margin:6px 0; white-space:nowrap; overflow:visible;}
#list { scrollbar-width: none; -ms-overflow-style: none; }
body { scrollbar-width: none; -ms-overflow-style: none; }
body::-webkit-scrollbar{ display:none; }


  .toggleFloating{position:fixed;top:12px;right:12px;z-index:400;width:36px;height:36px;border-radius:6px;border:0;background:rgba(255,255,255,0.03);color:#eaf4ff;font-size:18px;cursor:pointer;display:flex;align-items:center;justify-content:center}
  .tooltip{position:absolute;padding:8px 10px;font-size:13px;background:rgba(0,0,0,.8);color:#fff;border-radius:6px;pointer-events:none;opacity:0;transition:opacity .12s;max-width:260px;z-index:260}


  #detailPanel{position:sticky;top:0;left:0;width:100%;display:none;z-index:300;box-sizing:border-box;margin:8px 12px;pointer-events:auto}
  .cardFrame{position:relative;border-radius:12px;overflow:visible;box-shadow:0 18px 50px rgba(0,0,0,0.6)}
  .cardTop{position:relative;border-radius:12px 12px 0 0;background: repeating-linear-gradient(45deg, rgba(255,255,255,0.02) 0 2px, transparent 2px 24px), linear-gradient(180deg,var(--blue1),var(--blue2));background-blend-mode:overlay;z-index:10;padding:50px 12px 72px;transition:padding-bottom .12s}
  .cardTop::before{content:"";position:absolute;inset:0;background: radial-gradient(ellipse at 20% 20%, rgba(255,255,255,0.03), transparent 14%), radial-gradient(ellipse at 80% 70%, rgba(255,255,255,0.02), transparent 18%);mix-blend-mode:overlay;pointer-events:none}
  .pokemonTopWrap{position:relative;margin:0 auto;z-index:20;display:flex;gap:12px;align-items:flex-end;justify-content:center;flex-wrap:wrap;pointer-events:none;max-width:90%}
  .pokeNameOverlay{ position:absolute; left:50%; transform:translateX(-50%); top:8px; z-index:60; padding:6px 10px; border-radius:20px; font-weight:700; color:#fff; text-shadow:0 2px 6px rgba(0,0,0,0.6); pointer-events:none; font-size:20px; letter-spacing:1px; }
  .pokemonTopWrap img{ width: auto; max-width: clamp(110px, 28vw, 300px); max-height: clamp(80px, 28vh, 200px); border-radius:8px; box-shadow:0 10px 30px rgba(0,0,0,0.5); background:linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.04)); border:2px solid rgba(255,255,255,0.06); object-fit:contain; pointer-events:auto; }
  .miniBar{ position:absolute; left:50%; transform:translateX(-50%); bottom:-50px; z-index:30; display:flex; gap:10px; background:linear-gradient(180deg,var(--red),var(--red-dark)); padding:8px 14px; border-radius:28px; box-shadow:0 6px 16px rgba(0,0,0,0.35); border:2px solid rgba(0,0,0,0.12); align-items:center; max-width: calc(100% - 32px); width: auto; box-sizing: border-box; overflow-x: auto; overflow-y: hidden; -webkit-overflow-scrolling: touch; flex-wrap: nowrap; }
  .miniIcon{flex:0 0 auto;width:clamp(36px,6.5vw,64px);height:clamp(36px,6.5vw,64px);border-radius:8px;display:flex;align-items:center;justify-content:center;cursor:pointer;background:rgba(255,255,255,0.06);border:2px solid rgba(255,255,255,0.03);overflow:hidden}
  .miniIcon.active{outline:3px solid rgba(0,0,0,0.3);transform:translateY(-2px)}
  .miniIcon img{width:100%;height:100%;object-fit:cover;border-radius:6px;display:block}
  .cardBody{background:linear-gradient(180deg,#f6ffff 0%, #e0f9fc 100%);border-radius:0 0 12px 12px;padding:20px;padding-top:90px;color:#023b45;min-height:140px}
  .panelContent{display:flex;gap:16px;align-items:flex-start;flex-wrap:wrap}
  #miniIcons{display:flex;gap:8px;margin-bottom:8px}
  #miniIcons img{width:44px;height:44px;border-radius:6px;cursor:pointer;border:2px solid rgba(0,0,0,0.06);background:#fff}
  #detailDesc{ font-family: 'Press Start 2P', monospace; font-size: clamp(12px,1.6vw,18px); line-height:1.4; text-align:center; color:#07323a; margin:0; white-space:pre-wrap; word-break:break-word; }
  .detailCloseBtn{position:absolute;right:18px;top:18px;z-index:60;background:rgba(0,0,0,0.18);color:#fff;border:none;padding:8px 10px;border-radius:8px;cursor:pointer}
  .detailCloseBtn:hover{background:rgba(0,0,0,0.28)}

  @media (max-width:900px){
 
    #list{position:fixed;left:0;bottom:0;width:100%;height:220px;top:auto;z-index:350;padding:12px;border-radius:0;white-space:normal;}
    .toggleFloating{right:12px}
    .cardTop{padding-bottom:80px}
    .miniBar{bottom:12px}
  }
  @media (max-width:600px){
    .miniBar{ position:relative; left:auto; transform:none; bottom:auto; margin:12px auto 0; flex-wrap:wrap; overflow:visible; justify-content:center; max-width:100%; }
  }

  .miniBar::-webkit-scrollbar{height:12px}
  .miniBar::-webkit-scrollbar-thumb{background:rgba(0,0,0,0.2);border-radius:8px}

.toggleFloating.info{
  top: 56px;
  right: 12px;
  width:34px;
  height:34px;
  font-weight:700;
  font-family: 'Press Start 2P', monospace;
  background: rgba(255,255,255,0.02);
  border: 1px solid rgba(255,255,255,0.04);
  box-shadow: 0 6px 14px rgba(0,0,0,0.35);
}

#infoModal .modalOverlay{
  position:fixed;
  inset:0;
  background: rgba(0,0,0,0.45);
  z-index: 560;
  backdrop-filter: blur(3px);
}

#infoModal .modalCard{
  position:fixed;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
  z-index:570;
  width:min(760px,92%);
  max-width:760px;
  max-height:90vh;
  overflow-y:auto;
  overflow-x:hidden;
  border-radius:14px;
  box-shadow:0 28px 80px rgba(0,0,0,0.6);
  background:linear-gradient(180deg,#f6ffff 0%, #e0f9fc 100%);
  padding:20px 20px 28px 20px;
  box-sizing:border-box;
  -webkit-overflow-scrolling:touch;
}

#infoModal .modalCard::-webkit-scrollbar { width:0; height:0; display:none; }
#infoModal .modalCard { scrollbar-width:none; -ms-overflow-style:none; }

.scrollHint{
  position: sticky;
  bottom: 10px;
  margin-top: 14px;
  display: block;
  width: fit-content;
  left: 50%;
  transform: translateX(-50%);
  z-index: 580;
  pointer-events: none;
  font-size: 22px;
  line-height: 1;
  color: #023b45;
  background: rgba(255,255,255,0.92);
  padding: 6px 10px;
  border-radius: 12px;
  box-shadow: 0 6px 18px rgba(0,0,0,0.25);
  opacity: 0;
  transition: opacity .28s ease, transform .28s ease;
}

@keyframes hintBounce {
  0%   { transform: translateX(-50%) translateY(0); }
  50%  { transform: translateX(-50%) translateY(-6px); }
  100% { transform: translateX(-50%) translateY(0); }
}
.scrollHint.show{
  opacity: 1;
  animation: hintBounce 1.3s ease-in-out infinite;
}

@media (max-width:600px){
  .scrollHint{ font-size:18px; bottom:8px; padding:5px 8px; }
}

#infoModal h3{
  margin: 0 0 10px 0;
  font-family: 'Press Start 2P', monospace;
  font-size: 16px;
  color: #c4302b;
  text-align:center;
}
#infoModal .modalBody{
  font-family: Arial, sans-serif;
  color: #07323a;
  background: transparent;
  padding-top: 6px;
}
#infoModal .modalClose{
  position:absolute;
  right:14px;
  top:12px;
  background: rgba(0,0,0,0.12);
  color:#fff;
  border:none;
  width:34px;
  height:34px;
  border-radius:8px;
  cursor:pointer;
  z-index:580;
}
#infoModal a { color: #0080ff; text-decoration: none; font-weight: bold; }
#infoModal a:hover { text-decoration: underline; color: #00aaff; }
#infoModal .modalClose:hover{ background: rgba(0,0,0,0.22); }

@media (max-width:600px){
  #infoModal .modalCard{ width: calc(100% - 32px); padding: 16px; border-radius:10px; }
  .toggleFloating.info { right: 12px; top: 56px; }
}

#pageLoader {
  position: fixed;
  inset: 0;
  background: linear-gradient(180deg, rgba(5,6,21,0.95), rgba(5,6,21,0.92));
  z-index: 1200;
  display:flex;
  align-items:center;
  justify-content:center;
  flex-direction:column;
  gap:18px;
  transition: opacity .45s ease, visibility .45s ease;
  -webkit-font-smoothing:antialiased;
}
#pageLoader.hidden { opacity:0; visibility:hidden; pointer-events:none; }
#loaderBox { text-align:center; max-width:520px; padding:26px; border-radius:12px; background: rgba(0,0,0,0.35); box-shadow:0 18px 60px rgba(0,0,0,0.6); }
#loaderLogo { font-family:'Press Start 2P', monospace; letter-spacing:1px; color:#e6d190; font-size:14px; margin-bottom:6px; }
#loaderText { color:#eaf4ff; font-size:13px; margin-bottom:12px; }
.progressWrap { width:320px; max-width:80vw; height:14px; background: rgba(255,255,255,0.06); border-radius:8px; overflow:hidden; border:1px solid rgba(255,255,255,0.04); }
.progressBar { height:100%; width:0%; background: linear-gradient(90deg,#e7f0f2,#ffe50f,#676c71); transition: width .25s linear; }
#loaderCounter { margin-top:8px; font-size:12px; color:#dfeeff; }
#loaderHint { margin-top:8px; font-size:12px; color:#9fb7c1; opacity:0.9; }


.loaderSpinner {
  width: 200px;
  height: 200px;
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 6px auto;
}

</style>

<body>
<div id="pageLoader" role="status" aria-live="polite" aria-label="Cargando imágenes">
  <div id="loaderBox">
    <div id="loaderLogo">Cargando Árbol Evolutivo</div>
  <div class="loaderSpinner">
  <img src="Cargando.gif" alt="Cargando..." width="200" height="200">
</div>
    <div id="loaderText">Simulando Universo...</div>
    <div class="progressWrap" aria-hidden="false">
      <div class="progressBar" id="progressBar"></div>
    </div>
    <div id="loaderCounter" aria-atomic="true">0 / 0</div>
    <div id="loaderHint">Creando Mew´s tardar varios segundos.</div>
  </div>
</div>

<div class="wrap">
  <div id="detailPanel">
    <div class="cardFrame">
      <div class="cardTop">
        <div id="pokeNameOverlay" class="pokeNameOverlay" style="display:none"></div>
        <div class="pokemonTopWrap" id="pokemonTopWrap"></div>
        <div class="miniBar" id="miniBar" role="toolbar" aria-label="Variaciones"></div>
      </div>

      <div class="cardBody">
        <button class="detailCloseBtn" onclick="closePanel()">✖</button>
        <div class="panelContent">
          <div style="flex:1 1 100%">
            <h4 id="detailName" style="margin:0 0 8px 0;color:#052d33;font-size:16px;display:none"></h4>
            <p id="detailDesc"></p>
          </div>
        </div>
      </div>
    </div>
  </div>

<div class="main">
  <div id="tree">
    <canvas id="starfield"></canvas>
    <div class="tooltip" id="tooltip"></div>
  </div>

  <div id="list" class="hidden" aria-hidden="true">
    <h3>Listado</h3>
    <ul id="nodeList"></ul>
  </div>

  <button id="toggleListBtnFloating" class="toggleFloating" title="Mostrar lista">#</button>
  <button id="infoBtn" class="toggleFloating info" title="Información">ⓘ</button>
</div>

<div id="infoModal" aria-hidden="true" style="display:none;">
  <div class="modalOverlay" id="infoOverlay"></div>
  <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="infoTitle" aria-describedby="infoText">
    <button class="modalClose" id="infoClose" aria-label="Cerrar">✖</button>
    <h3 id="infoTitle">¡IMPORTANTE!</h3>
    <div id="infoText" class="modalBody">
<p style="white-space:pre-wrap; font-family: 'Press Start 2P', monospace; font-size:14px; line-height:1.4; color:#052d33;">Este Árbol Evolutivo Pokémon es una recreación inspirada en el video <a href="https://www.youtube.com/watch?v=nogvtR16mWM&t" target="_blank" style="color:#0077cc; text-decoration:none;">LA EVOLUCIÓN POKÉMON COMPLETA</a> del canal <a href="https://www.youtube.com/@ConvergenciaDigital" target="_blank" style="color:#c4302b; text-decoration:none;">Convergencia Digital</a>. Todos los créditos por la idea original corresponden a su autor.

Cambios y Justificacion:
<a style="color:#bcd88b; text-decoration:none;">-Ludicolo:</a>Está basado principalmente en un Kappa, al igual que Lombre. La historia mitológica del Kappa lo describe como la reencarnación de niños ahogados, y su nombre puede traducirse como “niño del río”, aunque esta denominación también hace referencia a su pequeño tamaño. En otras versiones, el Kappa es tratado como un críptido de tipo reptil, con características de tortuga humanoide: poseía caparazón, pico, manos y pies palmeados, además de escamas. Sin embargo, a pesar de tener escamas, su piel tenía una textura elástica similar a la de los anfibios, lo que lo convierte en una criatura bastante ambigua.

Ludicolo comparte muchas de estas características: tiene manos palmeadas como las tortugas de río, pies robustos similares a los de las tortugas terrestres, un pico (aunque más semejante al de un pato que al de una tortuga), y un cuerpo cubierto por lo que parece un plumaje o follaje vegetal, que refuerza su tipificación como Pokémon de tipo Planta.

En resumen, está inspirado en un ser mitológico con rasgos de reptil acuático y anfibio, mientras que su diseño también incorpora elementos de plantas, aves e incluso humanos (aludiendo a un sombrero y un poncho típicos de la cultura mexicana). Por ello, decidí ubicarlo en el árbol filogenético como si derivara de un ancestro común entre las Testudines (tortugas) y los Arcosaurios (grupo que incluye cocodrilos y aves), reflejando tanto su relación con las tortugas como sus características de protoave.

<a style="color:#b25a8f; text-decoration:none;">-Hoopa:</a>Está basado en un genio árabe, ser mitológico asociado con la magia y la manipulación del espacio. En el caso de Hoopa, sus anillos actúan como portales capaces de conectar distintos puntos del espacio e incluso otras dimensiones. Considerando que otros Pokémon inspirados en genios, como las Fuerzas de la Naturaleza, provienen de una dimensión alternativa, resulta coherente asumir que Hoopa también tiene un origen extradimensional o que habita en un espacio intermedio entre dimensiones. Por ello, se ubica dentro de la rama de los Pokémon Dimensionales.

<a style="color:#244e5a; text-decoration:none;">-Dhelmise:</a>En el mundo Pokémon, parece ser que todos los seres vivos e incluso aquellos que apenas pueden considerarse como tales derivan de Mew. Esto explicaría por qué existen Pokémon inorgánicos sin una lógica biológica aparente que también descienden de él.

Siguiendo esa misma idea, los distintos tipos de plantas también tendrían su origen en Mew, siendo los Pokémon de tipo Planta formas evolucionadas o derivadas de estas plantas primitivas.

Dhelmise, descrito como el alma de algas marinas que tomó posesión de un ancla, debería ubicarse dentro de la rama de las plantas, concretamente en la subrama de las Clorofitas, al basarse en algas verdes marinas. Sería, por tanto, el ancestro más antiguo de los Pokémon de tipo Planta, representando una planta ancestral que, al morir, trascendió su forma física y se convirtió en un Pokémon.

<a style="color:#e3a4b7; text-decoration:none;">-Slowpoke y Slowpoke de Galar:</a>Este Pokémon es bastante peculiar: a primera vista parece un mamífero, pero su larga cola recuerda más a la de un lagarto, ya que incluso puede desprenderse y regenerarse (un proceso conocido como autotomía). Tengo la teoría de que esto se debe a que Slowbro fue diseñado primero. Existen registros de su concepto desde 1990, cuando Pokémon aún se llamaba Capsule Monsters. Su diseño se basaba en el yōkai Sazae Oni, un demonio caracol.

Durante esa etapa temprana, los Pokémon tenían un estilo más cercano al de los kaijus, criaturas gigantes de la cultura popular japonesa. De hecho, en 1967 existía un grupo llamado Capsule Monsters que eran enemigos de Ultraman, lo que refuerza la relación conceptual entre Pokémon y los kaijus en sus orígenes.

Por lo tanto, Slowbro en sus primeras fases de desarrollo probablemente fue concebido como una especie de babosa (por su lentitud y el caparazón) con rasgos reptilianos inspirados en los kaijus. Si tuviera que señalar un kaiju con una morfología similar, mencionaría a Red King (1966), que, aunque no formó parte de los Capsule Monsters, sí pertenecío a la línea de los kaiju capsule.

Durante la transición conceptual hacia Pocket Monsters, se buscó redefinir ciertos diseños que originalmente tenían una apariencia de kaiju. Slowbro fue reinterpretado mediante la creación de Shellder, concebido como la contraparte simbiótica que completaría su diseño. Para establecer una base evolutiva coherente, se introdujo Slowpoke como forma previa. Su morfología fue ajustada hacia un organismo semiacuático con rasgos de hipopótamo, lo que permitió mantener la temática de lentitud y afinidad por el agua, al tiempo que su larga cola servía como punto de interacción con Shellder.

<a style="color:#00a587; text-decoration:none;">-Florges:</a>Está basado en las Alseides, ninfas de la mitología griega que habitan y protegen los bosques sagrados. Florges representa una reinterpretación de estas criaturas, fusionada con una flor que forma parte integral de su cuerpo.

A partir de la posición de Celebi en el árbol, se creó una nueva rama llamada Feae, destinada a agrupar a los distintos tipos de hadas y seres feéricos. Dentro de esta, Celebi puede considerarse un hada aérea o insectoide, mientras que Florges representa un tipo de hada floral, vinculada a la naturaleza y a la energía vital de las plantas.

<a style="color:#dbe496; text-decoration:none;">-Comfey:</a>Basado en un hada de las flores y en un lei hawaiano. A diferencia de Florges, las flores que porta no forman parte de su cuerpo, aunque parece mantener con ellas una relación simbiótica: Comfey revitaliza las flores y estas, a su vez, le proporcionan vitalidad, además de desprender fragancias relajantes y curativas.

Por ser un hada floral, es probable que comparta un ancestro común con Florges; sin embargo, ambas habrían seguido caminos evolutivos distintos: mientras Florges evolucionó para fusionarse con las plantas, Comfey lo hizo para establecer una relación simbiótica con ellas.

<a style="color:#414641; text-decoration:none;">-Espíritus Guardianes:</a>Los Tapu son espíritus tutelares de la naturaleza que toman la forma de tótems y guardianes regionales; encarnan aspectos del ciclo vital (nacimiento, crecimiento, madurez y término) y se manifiestan en la flora, fauna y geografía de sus islas. Están inspirados en las deidades hawaianas y, por ello, tienen un papel semidivino en la mitología de Alola. Filogenéticamente, tienen sentido dentro de la gran rama de las hadas, pero constituyen una subrama independiente: no descienden directamente de ninguna otra, sino que comparten un ancestro faérico común y se diferenciaron en guardianes elementales con funciones ecológicas y rituales propias.

<a style="color:#6c5095; text-decoration:none;">-Sableye:</a>Está basado en los Nibelungos, enanos oscuros del folclore germánico que habitan en las profundidades de la tierra y se dedican a la extracción de metales preciosos. Al igual que ellos, Sableye vive en cuevas donde busca gemas y piedras para alimentarse.

La razón por la que se ubica dentro de los Pokémon humanoides es tanto por su forma corporal (bípedo, con brazos, manos y rostro reconocible) como por su origen mitológico asociado a seres de apariencia humana. Además, su parentesco temático con otros Pokémon inspirados en criaturas similares, como Tinkaton, basada en un duende o gnomo, refuerza su posición dentro de esta rama.

<a style="color:#d7cfac; text-decoration:none;">-Mimikyu:</a>Está basado tanto en los disfraces de fantasmas como en el Bugul Noz, un espíritu feérico originario de los bosques de Bretaña. Este ser, último de su especie, vive en soledad debido a su apariencia horrenda, la cual provoca terror y angustia en quienes lo ven. Este rasgo se refleja en Mimikyu, que puede causar la muerte del susto a quien observa su verdadera forma. El Bugul Noz, sin embargo, no es malicioso: grita para advertir a las personas que no se acerquen, de modo similar a Mimikyu, que solo reacciona con enojo cuando alguien intenta mirar debajo de su disfraz.

Por su origen feérico, Mimikyu debe ubicarse dentro de la rama de las hadas, específicamente en una subrama de hadas sombrías, no por ser un espíritu maligno, sino por la tristeza, soledad y fatalidad que lo rodean, características que representan una faceta más melancólica del mundo feérico.

<a style="color:#8c6c9b; text-decoration:none;">-Mismagius:</a>Inspirado en brujas y, sobre todo, en las banshee, su línea evoca a estos espíritus feéricos femeninos, considerados mensajeras del Otro Mundo que anuncian la muerte con sus lamentos o gritos. Los cánticos y aullidos de Mismagius provocan migrañas, visiones y alucinaciones en quienes los escuchan, aunque en ocasiones sus cantos también pueden traer bienestar o suerte; su poder mágico emana de la voz, y la imagen de la bruja actúa como reforzador y canalizador de esa magia vocal. Debido a su vínculo feérico, función de mensajera entre mundos y efectos potenciadores o dañinos de su canto lo ubico en la rama de las hadas sombrías.

<a style="color:#606374; text-decoration:none;">-Marshadow:</a>Está inspirado en los nightmarchers, espíritus guerreros de la tradición hawaiana. Por su diseño y comportamiento (Un ser sombrío que copia técnicas marciales y actúa como espíritu guerrero) lo más coherente es ubicarlo en la rama de los Pokémon fantasma que se originaron a partir de humanos (es decir, entidades espirituales surgidas de almas humanas o vinculadas a humanos ancestrales). Esta posición lo emparenta conceptualmente con Pokémon como Gengar, Spiritomb, Yamask o Aegislash, que también representan almas, espíritus o fuerzas vinculadas a humanos u objetos humanos.

<a style="color:#3c3a3b; text-decoration:none;">-Darkrai:</a>No parece estar basado en ningún animal conocido; más bien, es un ser puramente sobrenatural que genera pesadillas de manera involuntaria con solo estar presente, siendo la contraparte conceptual de Cresselia.

Decidí ubicarlo en la rama de los Pokémon Dimensionales debido a diversas evidencias que sugieren que Darkrai habita o está conectado con una dimensión propia de las pesadillas.

En la película Pokémon: El desafío de Darkrai (The Rise of Darkrai), la batalla entre Dialga y Palkia provoca una fusión entre Pueblo Álamos y una dimensión oscura, en la cual los Pokémon afectados por el movimiento Brecha Negra de Darkrai aparecen como espíritus atrapados, lo que podría indicar que esa dimensión pertenece a Darkrai o está vinculada a su existencia.

Además, en el corto Pikachu, ¿Qué es esa llave?, un Klefki utiliza sus llaves para abrir portales a diferentes lugares y dimensiones; entre ellos, se muestra brevemente una dimensión oscura de tonos rojizos donde, a diferencia de las demás, solo aparece Darkrai.

Todo esto sugiere que las pesadillas de humanos y Pokémon pudieron dar origen a una dimensión onírica negativa, un reflejo oscuro del Dream World, de la cual Darkrai sería su manifestación o habitante natural, coexistiendo en paralelo al mundo físico.

<a style="color:#a2a6a9; text-decoration:none;">-Klefki:</a>Está basado en un duende doméstico, es decir, un ser feérico asociado a los hogares y conocido por robar o esconder pequeños objetos. En este caso, Klefki roba llaves, de las cuales se alimenta absorbiendo los iones metálicos que contienen. Esta característica explica su tipo Acero y su apariencia metálica, ya que depende de dichos iones para sobrevivir. Por su origen mitológico se le ubica en la rama de las hadas, aunque su linaje no está directamente relacionado con las hadas naturales o espirituales, sino que representa una manifestación más moderna y urbana de los seres feéricos.

<a style="color:#bd7389; text-decoration:none;">-Chimecho:</a>Inspirado en el fūrin, la tradicional campana de viento japonesa que suele colgarse en puertas y ventanas en verano. En la cultura japonesa se considera un amuleto que atrae la buena suerte y ahuyenta a los malos espíritus; su sonido fresco se asocia también con la purificación y la calma. Biológicamente en el universo Pokémon Chimecho tiene un cuerpo hueco que amplifica el viento y emite llamadas y ultrasonidos con efectos protectores y comunicativos.

Por estas razones, un origen cultural feérico, función protectora ligada al sonido y relación íntima con el viento, resulta coherente ubicarlo dentro de la rama de las hadas y junto a Celebi.

<a style="color:#a4b0d8; text-decoration:none;">-Exploud:</a>A primera vista, no parece estar basado en ningún animal en particular; sin embargo, la boca de Loudred y Exploud guarda un notable parecido con la de los hipopótamos. Por esta razón, decidí ubicarlo en la rama de los Whipomorfos, cercana a la de Hippowdon, debido a que ambos comparten un cuerpo robusto, terrestre y con orificios especializados: en Hippowdon sirven para expulsar arena, mientras que en Exploud cumplen la función de amplificar y modular el sonido. Además, puede trazarse una relación indirecta con Slowpoke, ya que al ser mordido por Shellder le permite adoptar una postura más equilibrada y parcialmente bípeda, algo similar a la morfología bípeda que presenta Exploud.

<a style="color:#61b5d9; text-decoration:none;">-Wobbuffet:</a>Está basado en el Okiagari-koboshi, un muñeco tradicional japonés hecho de papel maché que siempre se mantiene de pie y simboliza la perseverancia. Esta inspiración se refleja tanto en el concepto como en la expresión facial de Wobbuffet. Sin embargo, esta no es su única fuente de inspiración: también está basado en una persona real, Sanpei Hayashiya, un rakugo (comediante japonés que cuenta historias mientras permanece sentado en una sola posición). La frase característica de Sanpei era “Sō nansu, okusan!” (“¡Así son las cosas, señora!”), la cual inspiró directamente el nombre japonés de Wobbuffet, Sonans. Además, el gesto que hace Wobbuffet al llevarse la mano a la frente está basado en el mismo movimiento que realizaba Sanpei al decir su frase.

Por estas razones, ubiqué a Wobbuffet en la rama de los Pokémon humanoides, junto con otros inspirados en personas, como Snorlax, Hitmonchan y Hitmonlee. Desde un punto de vista biológico, podría interpretarse como un ser humanoide que evolucionó para especializarse en la defensa, desarrollando un cuerpo adaptado para absorber impactos y devolver energía, lo que explicaría su forma peculiar y su comportamiento pasivo.

<a style="color:#6e1e24; text-decoration:none;">-Volcanion:</a>Está basado en una máquina de vapor, lo cual se refleja en su fisiología, que combina características mecánicas y biológicas. También se asemeja a un géiser, ya que utiliza la presión del vapor interno para liberar poderosas explosiones de energía. Por esta razón, Volcanion puede considerarse una representación viviente de un volcán o un géiser, fusionando elementos naturales y tecnológicos. Su estructura y composición lo vinculan estrechamente con los Pokémon inorgánicos minerales.

<a style="color:#a89fcc; text-decoration:none;">-Swalot:</a>Está basado en el concepto de un estómago viviente debido a su capacidad de tragar y disolver cualquier cosa, aunque sus características biológicas, como su forma de desplazarse, su hábitat y su fisiología apuntan a que en realidad se trata de una especie de babosa. Su cuerpo blando, flexible y recubierto de mucosidad, junto con su preferencia por ambientes pantanosos o tóxicos, lo relacionan con los moluscos gasterópodos terrestres, lo que justifica su ubicación en esta rama junto a Pokémon como Accelgor y Goodra.

<a style="color:#bcbdbc; text-decoration:none;">-Revavroom:</a>En un principio podría parecer que se trata de un Pokémon de tipo veneno que poseyó un motor, lo que explicaría su combinación veneno/acero. Sin embargo, todo apunta a que ya era una especie cuyo cuerpo estaba formado por una mezcla de metal y sustancias tóxicas. El motor no sería algo externo, sino una estructura con la que Revavroom establece una relación simbiótica o una fusión natural, lo que le otorga su característica forma mecánica.

Por esta razón, me pareció correcto ubicarlo en una posición intermedia entre los Pokémon inorgánicos tóxicos y los Pokémon inorgánicos minerales, ya que combina elementos de ambos: la composición metálica propia de los minerales y la naturaleza venenosa de los compuestos químicos.

Las descripciones de la Pokédex y las imágenes de los Pokémon utilizadas en este proyecto son material publicado en <a href="https://www.wikidex.net/wiki/WikiDex" target="_blank" style="color:#ffd865; text-decoration:none;">WikiDex</a>, bajo la licencia Creative Commons Reconocimiento-NoComercial-CompartirIgual 3.0. Se agradece profundamente a WikiDex por su labor en la recopilación y documentación del universo Pokémon.</div>
 <div id="scrollHint" class="scrollHint" aria-hidden="true">↓</div>
    </div>
  </div>
</div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>

(function(){
  const loader = document.getElementById('pageLoader');
  const progressBar = document.getElementById('progressBar');
  const counter = document.getElementById('loaderCounter');
  const hint = document.getElementById('loaderHint');
  const MAX_WAIT_MS = 60000;
  const OBSERVE_NEW_MS = 8000;

  // tracked: Map<resolvedUrl, { state: 'pending'|'loaded'|'error' }>
  const tracked = new Map();
  let total = 0, loaded = 0;
  let lastAddedAt = Date.now();
  let observer = null;
  let timeoutHandle = null;

  function resolveUrl(url){
    if(!url) return null;
    try{
      const a = document.createElement('a');
      a.href = url;
      return a.href;
    }catch(e){ return url; }
  }

  function updateUI(){
    try {
      progressBar.style.width = (total === 0 ? 0 : Math.round((loaded/total)*100)) + '%';
      counter.textContent = `${loaded} / ${total}`;
      if(total > 600) hint.textContent = "Muchos Pókemon — puede tardar más. Si no avanza, espera o recarga.";
      else hint.textContent = "Creando Mew´s tardar varios segundos.";
    } catch(e){}
  }

  function markDone(){
    // desconectar observer/timeouts
    if(observer){ try{ observer.disconnect(); }catch(e){} observer = null; }
    if(timeoutHandle){ clearTimeout(timeoutHandle); timeoutHandle = null; }

    loader.classList.add('hidden');
    setTimeout(()=> {
      try { loader.style.display = 'none'; } catch(e){}
      setTimeout(()=> {
        if(typeof openInfoModal === 'function') {
          try { openInfoModal(); } catch(e){ document.getElementById('infoBtn').click(); }
        } else {
          document.getElementById('infoBtn').click();
        }
      }, 160);
    }, 480);
  }

  function markImageState(resolved, state){
    const prev = tracked.get(resolved);
    if(prev && prev.state === state) return;
    tracked.set(resolved, { state });
    // recalc loaded
    loaded = Array.from(tracked.values()).filter(v=>v.state === 'loaded' || v.state === 'error').length;
    total = tracked.size;
    if(loaded > total) loaded = total;
    updateUI();
    if(loaded >= total && total > 0) {
      // todas listas
      cleanupAndFinish();
    }
  }

  function trackUrl(url){
    const r = resolveUrl(url);
    if(!r) return;
    if(tracked.has(r)) return;
    // add as pending
    tracked.set(r, { state: 'pending' });
    total = Math.max(total, tracked.size);
    updateUI();

    // crear Image para que el navegador cargue
    const img = new Image();
    img.onload = () => markImageState(r,'loaded');
    img.onerror = () => markImageState(r,'error');
    // Iniciar carga
    img.src = r;

    // si ya está cacheado
    if(img.complete) {
      setTimeout(()=> {
        if(tracked.get(r) && tracked.get(r).state === 'pending') markImageState(r,'loaded');
      }, 5);
    }
  }

  function addMany(urls){
    if(!urls || !urls.length) return;
    urls.forEach(u => { try { trackUrl(u); lastAddedAt = Date.now(); } catch(e){} });
  }

  function cleanupAndFinish(){
    if(observer) {
      try { observer.disconnect(); } catch(e){}
      observer = null;
    }
    if(timeoutHandle) { clearTimeout(timeoutHandle); timeoutHandle = null; }
    // Dar un pequeño retardo para suavizar la UI
    setTimeout(()=> markDone(), 260);
  }

  function startTimeout(){
    if(timeoutHandle) clearTimeout(timeoutHandle);
    timeoutHandle = setTimeout(()=> {
      // marcar pendientes como error
      tracked.forEach((v,k) => {
        if(v.state === 'pending') tracked.set(k,{state:'error'});
      });
      loaded = Array.from(tracked.values()).filter(v=>v.state === 'loaded' || v.state === 'error').length;
      total = tracked.size;
      updateUI();
      cleanupAndFinish();
    }, MAX_WAIT_MS);
  }

  // MutationObserver para detectar imágenes añadidas por otros scripts/SVG
  function startObserver(){
    if(observer) return;
    try {
      observer = new MutationObserver((muts)=>{
        let any = false;
        for(const m of muts){
          if(m.type === 'childList'){
            m.addedNodes.forEach(n => {
              if(!(n instanceof Element)) return;
              const tn = n.tagName && n.tagName.toLowerCase();
              if(tn === 'img' || tn === 'image'){
                const url = getUrlFromNode(n);
                if(url){ trackUrl(url); any = true; lastAddedAt = Date.now(); }
              }
              const imgs = n.querySelectorAll && n.querySelectorAll('img, image');
              if(imgs && imgs.length){
                imgs.forEach(ii => { const url = getUrlFromNode(ii); if(url){ trackUrl(url); any = true; lastAddedAt = Date.now(); } });
              }
            });
          }
          if(m.type === 'attributes'){
            const targ = m.target;
            const tn = targ.tagName && targ.tagName.toLowerCase();
            if(tn === 'img' || tn === 'image'){
              const url = getUrlFromNode(targ);
              if(url){ trackUrl(url); any = true; lastAddedAt = Date.now(); }
            }
          }
        }
        if(any) updateUI();
      });

      observer.observe(document.documentElement || document.body, { childList:true, subtree:true, attributes:true, attributeFilter:['src','href'] });
    } catch(e){
      try { observer.observe(document.body, { childList:true, subtree:true, attributes:true, attributeFilter:['src','href'] }); } catch(e){}
    }

    // Inactividad -> desconectar observer
    const inactivityInterval = setInterval(()=>{
      if(!observer) { clearInterval(inactivityInterval); return; }
      if(Date.now() - lastAddedAt > OBSERVE_NEW_MS) {
        try { observer.disconnect(); } catch(e){}
        observer = null;
        clearInterval(inactivityInterval);
      }
    }, 700);

    startTimeout();
  }

  function getUrlFromNode(node){
    if(!node) return null;
    if(!node.tagName) return null;
    const tn = node.tagName.toLowerCase();
    if(tn === 'img') return node.currentSrc || node.src || node.getAttribute('src');
    if(tn === 'image'){
      try {
        return node.href && node.href.baseVal ? node.href.baseVal : node.getAttribute('href') || node.getAttributeNS('http://www.w3.org/1999/xlink','href');
      } catch(e){ return node.getAttribute('href') || node.getAttributeNS('http://www.w3.org/1999/xlink','href'); }
    }
    return null;
  }

  // expose API
  window.__imageLoader = {
    add: function(url){
      try { trackUrl(url); lastAddedAt = Date.now(); startObserver(); } catch(e){ console.error(e); }
    },
    addMany: function(urls){
      try { addMany(Array.isArray(urls)?urls:[]); startObserver(); } catch(e){ console.error(e); }
    },
    getStatus: function(){ return { total: tracked.size, loaded }; },
    // no exportamos markImageState públicamente porque lo maneja internamente
  };

  // Iniciar loader si el DOM ya está listo (para que la pantalla de carga se muestre)
  if(document.readyState === 'complete' || document.readyState === 'interactive'){
    setTimeout(()=> { startObserver(); updateUI(); }, 8);
  } else {
    window.addEventListener('DOMContentLoaded', ()=>{ startObserver(); updateUI(); }, {once:true});
  }

})();

(function waitForLoaderQueue(){
  if(window.__imageLoader && window.__pendingImageRegistration && window.__pendingImageRegistration.length){
    try {
      window.__imageLoader.addMany(window.__pendingImageRegistration);
    } catch(e){ console.error(e); }
    window.__pendingImageRegistration = [];
  }
  // si aún no existe, comprobamos 200ms después (máximo 10 veces)
  let tries = 0;
  function poll(){
    tries++;
    if(window.__imageLoader){
      if(window.__pendingImageRegistration && window.__pendingImageRegistration.length){
        try { window.__imageLoader.addMany(window.__pendingImageRegistration); } catch(e){}
        window.__pendingImageRegistration = [];
      }
      return;
    }
    if(tries < 10) setTimeout(poll, 200);
  }
  poll();
})();
</script>

<script>

(function(){
  const canvas = document.getElementById('starfield');
  const ctx = canvas.getContext('2d');
  const container = document.getElementById('tree');
  let stars = [];
  function resize(){ canvas.width = container.clientWidth; canvas.height = container.clientHeight; regen(); }
  function regen(){ stars = []; const n = Math.max(80, Math.floor((canvas.width*canvas.height)/90000)); for(let i=0;i<n;i++) stars.push({x:Math.random()*canvas.width,y:Math.random()*canvas.height,r:Math.random()*1.6+0.3,a:Math.random()*0.9+0.05}); }
  function draw(){ ctx.clearRect(0,0,canvas.width,canvas.height); for(const s of stars){ ctx.beginPath(); ctx.fillStyle = `rgba(255,255,255,${s.a})`; ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill(); } requestAnimationFrame(draw); }
  window.addEventListener('resize', resize); resize(); draw();
})();

/* ===== worker + preloader + buildTree (reemplazo completo) ===== */
let DATA = null;
const dataWorker = new Worker('worker.js');

dataWorker.addEventListener('message', (e) => {
  const msg = e.data || {};
  if (msg.type === 'status') {
    console.log('[worker] status:', msg.status, msg.url || '');
    return;
  }
  if (msg.type === 'error') {
    console.error('Error cargando data.json desde worker:', msg.error);
    return;
  }
if (msg.type === 'data') {
  DATA = msg.data;
  const images = Array.isArray(msg.images) ? msg.images : [];

  // Si el loader está listo, registramos las URLs con él para que empiece a trackear/cargar.
  // Si no está listo, guardamos en una cola y las procesamos cuando se registre.
  (function registerImagesWithLoader(imgs){
    if(!imgs || !imgs.length) {
      // igual construimos el árbol aun si no hay imgs
      try { buildTree(DATA); } catch(e){ console.error(e); }
      return;
    }

    // Si __imageLoader ya existe, úsalo
    if(window.__imageLoader && typeof window.__imageLoader.addMany === 'function'){
      try {
        window.__imageLoader.addMany(imgs);
      } catch(e){ console.error('error registrando imágenes en loader:', e); }
      // Construimos el árbol (puede añadir <image> SVG; loader seguirá trackeando)
      try { buildTree(DATA); } catch(e){ console.error(e); }
      return;
    }

    // Si el loader aún no existe — guardamos en una cola y esperaremos a que se registre.
    window.__pendingImageRegistration = window.__pendingImageRegistration || [];
    window.__pendingImageRegistration.push(...imgs);

    // Intentamos construir igual el árbol (si quieres que wait hasta que loader exista,
    // cambia esto para invocar buildTree más tarde). Por defecto construimos ahora.
    try { buildTree(DATA); } catch(e){ console.error(e); }
  })(images);
}
});

// Pedimos al worker que cargue el data.json
dataWorker.postMessage({ cmd: 'load', url: 'data.json' });


/* =================== buildTree(data) =================== */
function buildTree(data) {
  const container = d3.select("#tree");
  const width  = Math.max(1000, window.innerWidth*0.66);
  const height = Math.max(700, window.innerHeight);

  // Limpiar svg viejo
  container.selectAll("svg").remove();

  const svg = container.append("svg")
    .attr("viewBox",`0 0 ${width} ${height}`)
    .style("width","100%")
    .style("height","100%")
    .style("touch-action","none");

  const g = svg.append("g");
  const zoom = d3.zoom().scaleExtent([0.25,4]).on("zoom", (event)=> g.attr("transform", event.transform));
  svg.call(zoom);

  const root = d3.hierarchy(data);
  d3.tree().size([width-300, 0])(root);

  const defaultLen = 120;
  function assignY(n){ if(!n.children) return; n.children.forEach(c=>{ c.y = n.y + (c.data.linkLength || defaultLen); assignY(c); }); }
  root.y = 0; assignY(root);

  function assignShift(n){ const parentShift = n.parent ? (n.parent.shift||0) : 0; n.shift = parentShift + (n.data.xShift||0); if(n.children) n.children.forEach(assignShift); }
  assignShift(root);

  const xOffset = 150;
  root.each(d=>{ d.cx = d.x + xOffset + (d.shift||0); d.cy = height - 60 - d.y; });

  const linkGen = d3.linkVertical().x(d=>d.x).y(d=>d.y);

  g.selectAll(".link").data(root.links()).enter().append("path").attr("class","link").attr("d", d=>{
    const s=d.source, t=d.target;
    let sY = s.cy;
    if(s.data && s.data.isRing) sY = s.cy - (s.data.circleRadius||24) - ((s.data.circleStrokeWidth||6)/2);
    let tY = t.cy;
    if(t.data && typeof t.data.endOffset==="number") tY = t.cy + t.data.endOffset;
    if(t.data && t.data.isRing) tY = t.cy + (t.data.circleRadius||24) + ((t.data.circleStrokeWidth||6)/2);
    return linkGen({source:{x:s.cx,y:sY}, target:{x:t.cx,y:tY}});
  })
    .attr("fill","none")
    .attr("stroke", d=>d.target.data.linkColor || "#ffea00")
    .attr("stroke-width", d=>d.target.data.linkWidth || 10)
    .attr("stroke-linecap","butt")
    .attr("stroke-linejoin","round")
    .style("mix-blend-mode","normal")
    .style("filter","none")
    .style("shape-rendering","geometricPrecision");

  const nodes = root.descendants();
  const nodeG = g.selectAll(".node").data(nodes).enter().append("g").attr("class","node").attr("transform", d=>`translate(${d.cx},${d.cy})`);

  nodeG.filter(d=>d.data.isRing).append("circle")
    .attr("class","ring")
    .attr("r", d=>d.data.circleRadius || 24)
    .attr("stroke", d=>d.data.linkColor || "#ffea00")
    .attr("stroke-width", d=>d.data.circleStrokeWidth || 6)
    .attr("fill","none");

  nodeG.filter(d=>d.data.isRing && d.data.circleChild).each(function(d){
    const ch = d.data.circleChild;
    d3.select(this).append("image")
      .attr("href", ch.image)
      .attr("width",  ch.imgWidth  || (d.data.circleRadius*1.2))
      .attr("height", ch.imgHeight || (d.data.circleRadius*1.2))
      .attr("x", -(ch.imgWidth || (d.data.circleRadius*1.2))/2)
      .attr("y", -(ch.imgHeight || (d.data.circleRadius*1.2))/2)
      .style("cursor","pointer")
      .on("mouseover",(ev)=>showTooltip(ev,d))
      .on("mousemove",(ev)=>moveTooltip(ev))
      .on("mouseout",hideTooltip)
      .on("click",()=>showPanel(d));
  });

  nodeG.filter(d=> (d.data.image || (d.data.images && d.data.images.length)) && !d.data.isRing).append("image")
    .attr("href", d=> d.data.image || d.data.images[0])
    .attr("width", d=>d.data.imgWidth || 40)
    .attr("height", d=>d.data.imgHeight || 40)
    .attr("x", d=>-(d.data.imgWidth || 40)/2)
    .attr("y", d=>-(d.data.imgHeight || 40)/2)
    .style("cursor","pointer")
    .on("mouseover",(ev,d)=>showTooltip(ev,d))
    .on("mousemove",(ev)=>moveTooltip(ev))
    .on("mouseout",hideTooltip)
    .on("click",(ev,d)=>showPanel(d));

  const tooltip = document.getElementById('tooltip');
  function showTooltip(evt,d){ tooltip.innerHTML = `<strong>${d.data.name || ''}</strong>\n${d.data.description || ""}`; tooltip.style.opacity = 1; moveTooltip(evt); }
  function moveTooltip(evt){ tooltip.style.left = (evt.pageX + 12) + "px"; tooltip.style.top = (evt.pageY - 8) + "px"; }
  function hideTooltip(){ tooltip.style.opacity = 0; }

  // panel / mini bar
  function adjustCardTopForMiniBar(){
    const cardTop = document.querySelector('.cardTop');
    const miniBar = document.getElementById('miniBar');
    if(!cardTop || !miniBar) return;
    const needed = 60;
    cardTop.style.paddingBottom = `${needed}px`;
    miniBar.style.maxWidth = `${Math.max(160, cardTop.clientWidth - 32)}px`;
  }

  function showPanel(d){
    const panel = document.getElementById('detailPanel');
    const pokemonTopWrap = document.getElementById('pokemonTopWrap');
    const miniBar = document.getElementById('miniBar');
    const nameOverlay = document.getElementById('pokeNameOverlay');
    const descEl = document.getElementById('detailDesc');

    pokemonTopWrap.innerHTML = "";
    miniBar.innerHTML = "";
    nameOverlay.style.display = 'none';

    nameOverlay.textContent = d.data.name || '';
    nameOverlay.style.display = (d.data.name && String(d.data.name).trim().length>0) ? 'block' : 'none';

    const imagesToShow = Array.isArray(d.data.images) && d.data.images.length ? d.data.images : (d.data.image ? [d.data.image] : (d.data.circleChild && d.data.circleChild.image ? [d.data.circleChild.image] : []));
    imagesToShow.forEach(src => {
      const im = document.createElement('img');
      im.src = src;
      im.alt = d.data.name || '';
      pokemonTopWrap.appendChild(im);
    });

    descEl.textContent = d.data.description || "Sin descripción.";

    if(Array.isArray(d.data.variations) && d.data.variations.length){
      d.data.variations.forEach((v,i)=>{
        const cell = document.createElement('div');
        cell.className = 'miniIcon';
        cell.setAttribute('role','button');
        cell.setAttribute('tabindex','0');
        if (v.icon && (/\.(png|jpe?g|svg)$/i).test(v.icon)){
          const img = document.createElement('img');
          img.src = v.icon;
          img.alt = v.description || '';
          cell.appendChild(img);
        } else {
          cell.textContent = v.label || v.icon || (`V${i+1}`);
        }
        cell.title = v.description || "";
        cell.onclick = () => {
          Array.from(miniBar.children).forEach(c=>c.classList.remove('active'));
          cell.classList.add('active');
          descEl.textContent = v.description || descEl.textContent;
          adjustCardTopForMiniBar();
        };
        cell.onkeydown = (ev) => { if(ev.key === 'Enter' || ev.key === ' ') cell.onclick(); };
        miniBar.appendChild(cell);
        if(i===0) cell.classList.add('active');
      });
    } else {
      const placeholder = document.createElement('div');
      placeholder.className = 'miniIcon';
      placeholder.textContent = '—';
      miniBar.appendChild(placeholder);
    }

    panel.style.display = 'block';
    requestAnimationFrame(()=>{
      adjustCardTopForMiniBar();
      // actualizamos posiciones de botones globalmente
      if (typeof window.updateFloatingBtnPosition === 'function') window.updateFloatingBtnPosition();
    });
  }

  function closePanel(){ document.getElementById('detailPanel').style.display = 'none'; if (typeof window.updateFloatingBtnPosition === 'function') window.updateFloatingBtnPosition(); }

  // Exponer funciones globales para que los botones en HTML funcionen (onclick="closePanel()")
  window.showPanel = showPanel;
  window.closePanel = closePanel;

  // listado
  function fillList(node, ul) {
    const hasName = node && node.data && node.data.name && String(node.data.name).trim().length > 0;

    if (hasName) {
      const li = document.createElement('li');
      li.textContent = node.data.name;

      if (node.data.linkColor) {
        li.style.color = node.data.linkColor;
        li.style.textShadow = `
          1px 1px 0 #fff,
          -1px 1px 0 #fff,
          1px -1px 0 #fff,
          -1px -1px 0 #fff
        `;
        li.style.fontWeight = "bold";
      }

      ul.appendChild(li);

      if (node.children && node.children.length) {
        const subUl = document.createElement('ul');
        li.appendChild(subUl);
        node.children.forEach(child => fillList(child, subUl));
      }
    } else {
      if (node.children && node.children.length) {
        node.children.forEach(child => fillList(child, ul));
      }
    }
  }

  const nodeListEl = document.getElementById('nodeList');
  nodeListEl.innerHTML = '';
  fillList(root, nodeListEl);

  nodeListEl.addEventListener('click', (ev) => {
  const li = ev.target.closest('li');
  if (!li) return;
  const name = li.firstChild.textContent.trim();
  if (!name) return;

  // Buscar el nodo objetivo (nodes está en scope)
  const targetNode = nodes.find(n => n.data.name && n.data.name.trim() === name);
  if (!targetNode) return;

  // calcular transform objetivo
  const currentTransform = d3.zoomTransform(svg.node());
  const currentScale = currentTransform.k || 1;

  // Deseado: mantener la escala actual, centrar en targetNode
  const tx = (width / 2) - targetNode.cx * currentScale;
  const ty = (height / 2) - targetNode.cy * currentScale;
  const targetTransform = d3.zoomIdentity.translate(tx, ty).scale(currentScale);

  // OPTIMIZACIÓN: ocultar imágenes durante la animación para reducir repaints
  // 1) seleccionamos imágenes dentro del SVG (elementos <image>), y también <img> internos si aplica
  const svgNode = svg.node();
  const svgImgs = Array.from(svgNode.querySelectorAll('image'));
  // Si tienes también <img> dentro del SVG wrapper (no debería), puedes incluirlas:
  // const htmlImgs = Array.from(document.querySelectorAll('#tree img'));
  // const allImgs = svgImgs.concat(htmlImgs);
  const allImgs = svgImgs;

  // Guardamos visibilidad previa y desactivamos puntero
  allImgs.forEach(img => {
    try {
      img.setAttribute('data-prev-visibility', img.style.visibility || '');
      img.style.visibility = 'hidden';
      img.style.pointerEvents = 'none';
    } catch(e){}
  });

  // Ayuda al compositor: pide al navegador que use composición de GPU para la g transformada
  const gNode = g.node();
  const prevWill = gNode.style.willChange || '';
  gNode.style.willChange = 'transform';

  // Opcional: corta interacciones durante transición
  svgNode.style.pointerEvents = 'none';

  // Ejecutamos la transición (duración más corta para menor trabajo)
  const TRANS_DUR = 600; // ms (ajustable; menor = menos trabajo)
  svg.transition()
    .duration(TRANS_DUR)
    .call(zoom.transform, targetTransform)
    .on('end', () => {
      // restaurar visibilidad y puntero
      allImgs.forEach(img => {
        try {
          const prev = img.getAttribute('data-prev-visibility');
          img.style.visibility = prev || '';
          img.style.pointerEvents = '';
          img.removeAttribute('data-prev-visibility');
        } catch(e){}
      });

      // restaurar will-change y puntero del svg
      try { gNode.style.willChange = prevWill; } catch(e){}
      svgNode.style.pointerEvents = '';

      // forzar actualización ligera para asegurar que todo quede estable
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          // nada más, solo forzar dos frames
        });
      });
    });

  // También consideramos cancelar la transición si se hace otra acción:
});

  // Botones flotantes: reasignamos handlers de forma determinista (sobrescribe handlers previos)
  const floatingBtn = document.getElementById('toggleListBtnFloating');
  const listEl = document.getElementById('list');
  const infoBtn = document.getElementById('infoBtn');
  const infoModal = document.getElementById('infoModal');
  const infoOverlay = document.getElementById('infoOverlay');
  const infoClose = document.getElementById('infoClose');

  function updateFloatingBtnPosition(){
    const panel = document.getElementById('detailPanel');
    if(panel && panel.style.display !== 'none'){
      const rect = panel.getBoundingClientRect();
      const top = (rect.bottom > 8) ? (rect.bottom + 8) : 12;
      floatingBtn.style.top = `${top}px`;
    } else floatingBtn.style.top = '12px';

    const listRect = listEl.getBoundingClientRect();
    if(listEl.classList.contains('hidden')) floatingBtn.style.right = '12px';
    else {
      if(window.innerWidth <= 900 && listRect.width > window.innerWidth - 60){
        floatingBtn.style.right = '12px';
      } else {
        floatingBtn.style.right = `${Math.max(12, listRect.width + 24)}px`;
      }
    }

    try {
      const fTop = parseInt(floatingBtn.style.top || window.getComputedStyle(floatingBtn).top) || 12;
      const gap = 8;
      if(infoBtn){
        infoBtn.style.top = `${fTop + floatingBtn.offsetHeight + gap}px`;
        infoBtn.style.right = floatingBtn.style.right || window.getComputedStyle(floatingBtn).right || '12px';
      }
    } catch(e){}
  }

  // Hacemos global la función para evitar conflictos
  window.updateFloatingBtnPosition = updateFloatingBtnPosition;

  // Reasignamos onclick (sobrescribe eventListeners previos)
  if(floatingBtn){
    floatingBtn.onclick = (e) => {
      e && e.stopPropagation();
      const prevScroll = window.scrollY || window.pageYOffset || 0;
      if(listEl.classList.contains('hidden')){
        listEl.classList.remove('hidden');
        listEl.setAttribute('aria-hidden','false');
        floatingBtn.title = "Ocultar lista";
      } else {
        listEl.classList.add('hidden');
        listEl.setAttribute('aria-hidden','true');
        floatingBtn.title = "Mostrar lista";
      }
      updateFloatingBtnPosition();
      setTimeout(()=> { window.scrollTo({ top: prevScroll, behavior: 'instant' }); }, 0);
    };
  }

  if(infoBtn){
    infoBtn.onclick = (e) => { e && e.stopPropagation(); openInfo(); };
  }

  function openInfo(){
    if(!infoModal) return;
    infoModal.style.display = 'block';
    infoModal.setAttribute('aria-hidden','false');
    setTimeout(()=>updateScrollHint(),60);
  }
  function closeInfo(){
    if(!infoModal) return;
    infoModal.style.display = 'none';
    infoModal.setAttribute('aria-hidden','true');
  }
  if(infoClose) infoClose.onclick = closeInfo;
  if(infoOverlay) infoOverlay.onclick = closeInfo;
  document.addEventListener('keydown', (e)=>{ if(e.key === 'Escape' && infoModal && infoModal.style.display === 'block'){ closeInfo(); }});

  // Reasignar onclick del botón cerrar detalle para asegurar enlace correcto
  const detailCloseBtn = document.querySelector('.detailCloseBtn');
  if(detailCloseBtn) detailCloseBtn.onclick = () => { try{ window.closePanel(); }catch(e){} };

  // scrollHint helpers
  const modalCard = document.querySelector('#infoModal .modalCard');
  const scrollHint = document.getElementById('scrollHint');
  function updateScrollHint(){
    if(!modalCard || !scrollHint) return;
    const isScrollable = modalCard.scrollHeight > modalCard.clientHeight + 2;
    const atBottom = (modalCard.scrollTop + modalCard.clientHeight) >= (modalCard.scrollHeight - 4);
    if(isScrollable && !atBottom) scrollHint.classList.add('show');
    else scrollHint.classList.remove('show');
  }
  if(modalCard) modalCard.addEventListener('scroll', updateScrollHint);
  window.addEventListener('resize', () => setTimeout(updateScrollHint, 80));

  // Observador para actualizar posiciones cuando el contenido del panel cambie
  try {
    const obs = new MutationObserver(()=>{ updateFloatingBtnPosition(); adjustCardTopForMiniBar(); });
    const dp = document.getElementById('detailPanel');
    if(dp) obs.observe(dp, { childList:true, subtree:true });
  } catch(e){}

  window.addEventListener('resize', ()=>{ updateFloatingBtnPosition(); adjustCardTopForMiniBar(); });
  window.addEventListener('scroll', updateFloatingBtnPosition);

  // Centrar en root al final
  (function centerOnRoot(){
    const tx = (width/2) - (root.cx||0);
    const ty = (height/2) - (root.cy||0);
    svg.call(zoom.transform, d3.zoomIdentity.translate(tx,ty).scale(1));
    setTimeout(()=>{ updateFloatingBtnPosition(); adjustCardTopForMiniBar(); },50);
  })();
} // end buildTree
</script>
</body>
</html>